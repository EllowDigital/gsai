{"version":3,"file":"use-scroll-animation-B4VHXeN3.js","sources":["../../src/hooks/use-scroll-animation.tsx"],"sourcesContent":["import { useEffect, useRef, RefObject } from 'react';\r\n\r\ninterface ScrollAnimationOptions {\r\n  threshold?: number;\r\n  rootMargin?: string;\r\n  once?: boolean;\r\n  delay?: number;\r\n  animationType?: 'fade' | 'slide' | 'zoom' | 'flip';\r\n  direction?: 'up' | 'down' | 'left' | 'right';\r\n}\r\n\r\n/**\r\n * Enhanced hook to add scroll-triggered animations to elements with improved performance.\r\n */\r\nexport const useScrollAnimation = <T extends HTMLElement>(options: ScrollAnimationOptions = {}): RefObject<T> => {\r\n  const elementRef = useRef<T>(null);\r\n\r\n  // Destructuring options with default values\r\n  const {\r\n    threshold = 0.1,\r\n    rootMargin = '0px 0px -10% 0px',\r\n    once = true,\r\n    delay = 0,\r\n    animationType = 'fade',\r\n    direction = 'up'\r\n  } = options;\r\n\r\n  useEffect(() => {\r\n    const element = elementRef.current;\r\n    if (!element) return;\r\n\r\n    // Add appropriate initial animation classes\r\n    element.classList.add('scroll-animate', `animate-${animationType}-${direction}`);\r\n\r\n    // Apply delay if specified\r\n    if (delay > 0) {\r\n      element.style.transitionDelay = `${delay}ms`;\r\n    }\r\n\r\n    // Intersection Observer to trigger animations when the element enters the viewport\r\n    const observer = new IntersectionObserver(\r\n      (entries) => {\r\n        entries.forEach((entry) => {\r\n          if (entry.isIntersecting) {\r\n            requestAnimationFrame(() => {\r\n              const target = entry.target as HTMLElement;\r\n\r\n              // Add visibility class to trigger animation\r\n              target.classList.add('visible');\r\n              target.style.willChange = 'opacity, transform';\r\n\r\n              // Remove will-change after animation completes to optimize performance\r\n              setTimeout(() => {\r\n                target.style.willChange = 'auto';\r\n              }, 1000); // Timeout should match animation duration\r\n\r\n              // If 'once' is true, stop observing after first visibility\r\n              if (once) {\r\n                observer.unobserve(target);\r\n              }\r\n            });\r\n          } else if (!once) {\r\n            requestAnimationFrame(() => {\r\n              const target = entry.target as HTMLElement;\r\n              target.classList.remove('visible');\r\n            });\r\n          }\r\n        });\r\n      },\r\n      { threshold, rootMargin }\r\n    );\r\n\r\n    // Start observing the element\r\n    observer.observe(element);\r\n\r\n    return () => {\r\n      // Cleanup observer on component unmount or when element is no longer present\r\n      if (element) {\r\n        observer.unobserve(element);\r\n      }\r\n    };\r\n  }, [threshold, rootMargin, once, delay, animationType, direction]);\r\n\r\n  return elementRef;\r\n};\r\n\r\nexport default useScrollAnimation;\r\n"],"names":["useScrollAnimation","options","elementRef","useRef","threshold","rootMargin","once","delay","animationType","direction","useEffect","element","observer","entries","entry","target"],"mappings":"wCAcO,MAAMA,EAAqB,CAAwBC,EAAkC,KAAqB,CACzG,MAAAC,EAAaC,SAAU,IAAI,EAG3B,CACJ,UAAAC,EAAY,GACZ,WAAAC,EAAa,mBACb,KAAAC,EAAO,GACP,MAAAC,EAAQ,EACR,cAAAC,EAAgB,OAChB,UAAAC,EAAY,IAAA,EACVR,EAEJS,OAAAA,EAAAA,UAAU,IAAM,CACd,MAAMC,EAAUT,EAAW,QAC3B,GAAI,CAACS,EAAS,OAGdA,EAAQ,UAAU,IAAI,iBAAkB,WAAWH,CAAa,IAAIC,CAAS,EAAE,EAG3EF,EAAQ,IACFI,EAAA,MAAM,gBAAkB,GAAGJ,CAAK,MAI1C,MAAMK,EAAW,IAAI,qBAClBC,GAAY,CACHA,EAAA,QAASC,GAAU,CACrBA,EAAM,eACR,sBAAsB,IAAM,CAC1B,MAAMC,EAASD,EAAM,OAGdC,EAAA,UAAU,IAAI,SAAS,EAC9BA,EAAO,MAAM,WAAa,qBAG1B,WAAW,IAAM,CACfA,EAAO,MAAM,WAAa,QACzB,GAAI,EAGHT,GACFM,EAAS,UAAUG,CAAM,CAC3B,CACD,EACST,GACV,sBAAsB,IAAM,CACXQ,EAAM,OACd,UAAU,OAAO,SAAS,CAAA,CAClC,CACH,CACD,CACH,EACA,CAAE,UAAAV,EAAW,WAAAC,CAAW,CAC1B,EAGA,OAAAO,EAAS,QAAQD,CAAO,EAEjB,IAAM,CAEPA,GACFC,EAAS,UAAUD,CAAO,CAE9B,CAAA,EACC,CAACP,EAAWC,EAAYC,EAAMC,EAAOC,EAAeC,CAAS,CAAC,EAE1DP,CACT"}